---
title: "Logboek_Yamila_Medulloblastoma"
authors: "<Yamila Timmer(442914)>"
date: "`r Sys.Date()`"
bibliography: "logboek_yamila.bib"
output:
  html_document:
    toc: yes
    toc_depth: 3
    toc_float:
      collapsed: yes
      smooth_scroll: yes
editor_options: 
  markdown: 
    wrap: 72
---

```{r}
library(dplyr)
library(trackViewer)
library(plotrix)
library(GenomicRanges)
library(Rsamtools)
```


# Voorbereiding

## Het doel/opzet van de cursus

Voor week 1 vind ik het belangrijk om duidelijk te krijgen wat het doel
is van deze cursus, aan de hand van de informatie op Blackboard ben ik
tot de volgende conclusie gekomen: het doel van deze course is om te
leren een pipeline te ontwikkelen, met behulp van Galaxy, die voor een
ziekte kan voorspellen of een patiënt mogelijk variaties heeft in zijn
genoom die aan de ziekte kunnen worden gelinkt. Ik heb samen met mijn
groepsgenoot gekozen voor '*medulloblastoma*' als aandoening. De reden
dat wij hiervoor hebben gekozen is omdat dit een van de meest
voorkomende vormen van kanker is bij jonge kinderen, maar er toch nog
maar weinig bekend is over de exacte oorzaak.

Vragen die wij willen onderzoeken zijn o.a.;

-   Welke SNP's er voorkomen bij medulloblastomen,

-   Welke tools wij het beste voor deze analyse kunnen gebruiken in
    Galaxy.

Voor deze analyse zullen wij de medulloblastoom DNA-seq data (MB-DNASeq)
gebruiken. Deze is terug te vinden op het BIN-netwerk in de volgende
locatie: /commons/Themas/Thema05/2024/. Deze data bevat 5 verschillende
samples, waarvan wij de sample van patiënt 5 zullen gebruiken
(SRR26913194). De data voor deze sample bestaat uit 2 FASTQ-bestanden,
met de forward (\_1)- en reverse (\_2) read, de data bestaat uit
next-generation Illumina NextSeq 500 reads (paired-end) en bestaat uit
de exomen van bepaalde genen in een vooraf opgesteld genpanel. Dit
genpanel bevat 130 genen die met het ontstaan van kanker in verband
worden gebracht. Door een 'klein' genpanel op te stellen van 130 genen,
in plaats van alle 26.564 menselijke genen te sequencen, kunnen er meer
reads worden verkregen van de genen die daadwerkelijk interessant zijn
bij het ontstaan van deze aandoening.

De applicaties die wij voor dit project zullen gebruiken zijn:

-   De wetenschappelijke workflow manager Galaxy, voor de analyse,
-   R voor het bijhouden van de bevindingen en de manier waarop de
    analyse is uitgevoerd, dit vind plaats in de vorm van een logboek,
-   Github voor het delen van bestanden.

De tools die wij op Galaxy zullen gebruiken om de analyse uit te voeren
zijn: - Quality Control: - FASTQC - Trimmomatic - Mapping: - BWA -
Variant detection: - LoFreq

## Achtergrondinformatie medulloblastoma

Voordat ik ben begonnen met het gebruik van Galaxy, heb ik informatie
opgezocht over medulloblastomen, om te achterhalen wat deze aandoening
inhoudt, op wie het vooral effect heeft en waarom het belangrijk is om
hier onderzoek naar te doen.

Medulloblastomen vormen de meestvoorkomende maligne hersentumor in
kinderen, namelijk bijna 20%. Medullablastomen zijn een embryonale
neuroepitheliale tumor in het cerebellum [afbeelding 1], dit houdt in
dat de tumor ontstaat vanuit bepaalde embryonale stamcellen. Behandeling
bestaat uit een combinatie van het chirurgisch verwijderen van de tumor,
met daarop volgend radio-en chemotherapie. De 5-jaar overlevingskans
lijkt nog niet heel duidelijk onderzocht en is volgens de literatuur
tussen de 20 en 90 procent. Deze grote range is te danken aan het feit
dat veel verschillende factoren een rol spelen bij de overlevingskans,
bijvoorbeeld de leeftijd wanneer de aandoening wordt vastgesteld, de
aanwezigheid van metastasen (uitzaaiingen) en afwijkingen in het genoom,
denk hierbij aan copy-number variations. Hierbij kan het zijn dat er van
bepaalde genen meer of minder kopieeen voorkomen, in het geval dat het
een gen is dat te maken heeft met bijvoorbeeld de celdeling, kan dit de
kans op kanker sterk verhogen. Medulloblastoom is een 'high-grade' tumor
(snel delend) en heeft een grote kans om uit te zaaien in het
hersenvocht [@Mahapatra2023].

Het is onbekend wat de oorzaak is van medulloblastomen, uit meerdere
onderzoeken blijkt dat er een mogelijke link is tussen het dieet van de
moeder tijdens de zwangerschap of de aanwezigheid van
auto-immuun/bloedziekten. Ook zijn bepaalde virale infecties mogelijk
een oorzaak, zoals virale John Cunningham infecties of human
cytomegalovirus infections tijdens kindertijd. Ook wordt er gedacht dat
erfelijkheid een rol speelt en dat bepaalde aandoeningen de kans
verhogen op het ontstaan van medullablastomen, dit zijn: Gorlinsyndroom,
Fanconi anemie, Turcotsyndroom, Li-Fraumeni syndroom [@Mahapatra2023].

Het is duidelijk dat er nog veel onbekend is over de exacte etiologie
van deze aandoening en juist omdat deze aandoening een van de meest
voorkomende vormen van kanker is bij (jonge) kinderen, denk ik dat het
maatschappelijk erg belangrijk is om hier verder onderzoek naar te doen.
In de literatuur wordt onder andere copy-number variation en
erfelijkheid vermeld, dit zijn beide onderdelen die kunnen worden
onderzocht door mapping aan de hand van een referentiegenoom.

![Weergave van locatie van medulloblastoom, in het cerebellum
[@MayoClinic2023]](medulloblastoom_img.webp){width="50%"}

## Galaxy tutorial

Nu ik een beter beeld heb gekregen van de aandoening heb ik besloten om
te beginnen met Galaxy, voordat ik aan de daadwerkelijke opdracht ben
begonnen heb ik een Galaxy tutorial gevolgd, om bekend te raken met de
workflow manager. De tutorial die ik hiervoor heb gebruikt is '*Galaxy
Basics for genomics*', afkomstig van de volgende website:
<https://galaxyproject.github.io/training-material/topics/introduction/tutorials/galaxy-intro-101/tutorial.html>

In deze tutorial heb ik geleerd om: 

- Een history aan te maken 
- Bestanden in te laden 
- Tools te gebruiken (datamash, intersect intervals, sort, select first, compare two datasets) - Een history om te zetten naar een workflow

# Quality Control met Galaxy

## Input

Forward en reverse read van sample 5:

-   SRR26913194_1.fastq
-   SRR26913194_2.fastq

| Input Parameter                                                     | Value                     |
|-----------------------------------------------|-------------------------|
| Raw read data from your current history                             | 1: SRR26913194_1.fastq.gz |
| Contaminant list                                                    |                           |
| Adapter list                                                        |                           |
| Submodule and Limit specifing file                                  |                           |
| Disable grouping of bases for reads \>50bp                          | 0                         |
| Lower limit on the length of the sequence to be shown in the report | Not available.            |
| Length of Kmer to look for                                          | 7                         |

| Input Parameter                                                     | Value                     |
|-----------------------------------------------|-------------------------|
| Raw read data from your current history                             | 1: SRR26913194_2.fastq.gz |
| Contaminant list                                                    |                           |
| Adapter list                                                        |                           |
| Submodule and Limit specifing file                                  |                           |
| Disable grouping of bases for reads \>50bp                          | 0                         |
| Lower limit on the length of the sequence to be shown in the report | Not available.            |
| Length of Kmer to look for                                          | 7                         |

## Output

-   Webpage
-   Raw data

## Trimmomatic

Om de kwaliteit van de reads te verhogen maak ik gebruik van de
Trimmomatic tool, deze pas ik toe op SRR26913194_1.fastq.gz en
SRR26913194_2.fastq.gz (paired-end), met de volgende parameters:

| Input Parameter                                                                                         | Value                                       |
|----------------------------------------------|--------------------------|
| Single-end or paired-end reads?                                                                         | pair_of_files                               |
| Input FASTQ file (R1/first of pair)                                                                     | 1: SRR26913190_1.fastq.gz                   |
| Input FASTQ file (R2/second of pair)                                                                    | 2: SRR26913190_2.fastq.gz                   |
| Perform initial ILLUMINACLIP step?                                                                      | 1                                           |
| Select standard adapter sequences or provide custom?                                                    | standard                                    |
| Adapter sequences to use                                                                                | TruSeq3 (paired-ended, for MiSeq and HiSeq) |
| Maximum mismatch count which will still allow a full match to be performed                              | 2                                           |
| How accurate the match between the two 'adapter ligated' reads must be for PE palindrome read alignment | 30                                          |
| How accurate the match between any adapter etc. sequence must be against a read                         | 10                                          |
| Minimum length of adapter that needs to be detected (PE specific/palindrome mode)                       | 8                                           |
| Always keep both reads (PE specific/palindrome mode)?                                                   | 1                                           |
| Select Trimmomatic operation to perform                                                                 | SLIDINGWINDOW                               |
| Number of bases to average across                                                                       | 4                                           |
| Average quality required                                                                                | 20                                          |
| Select Trimmomatic operation to perform                                                                 | MINLEN                                      |
| Minimum length of reads to be kept                                                                      | 40                                          |
| Output trimlog file?                                                                                    | 0                                           |
| Output trimmomatic log messages?                                                                        | 0                                           |

De 'operations' die ik heb ingesteld zijn:

-   **SLIDINGWINDOW**: gaat met een window van 4 basen over de hele read
    heen, wanneer de gemiddelde kwaliteit binnen deze window lager is
    dan een Phred-score van 20, knipt hij de read en houdt hij het stuk
    met de hoogste kwaliteit.

-   **MINLEN**: behoudt de read niet wanneer deze korter is dan 40
    (aangegeven MINLEN voor data met reads van 75bp).

```{r}
paste("Verwijderde reads door Trimmomatic: ", 21866605-20877004)
```

## Resultaten

### Basic statistics

![Basic statistics uit FastQC Report, forward
read](SRR26913194_1_FASTQ_1st_run.png){width="400px"} ![Basic statistics
uit FastQC Report, reverse
read](SRR26913194_2_FASTQ_1st_run.png){width="400px"}

De basic statistics tussen de forward en reverse read lijken sterk met
elkaar overeen te komen, op 1 onderdeel na, zo is het GC-gehalte bij de
reverse read 1% lager en verwacht ik dat de GC-gehalte normaalverdeling
bij de reverse read meer zal afwijken dan de forward read.

![Per base sequence quality voor SRR26913194_1, vóór het
trimmen](SRR26913194_1_FASTQ_base_quality.png) ![Per base sequence
quality voor SRR26913194_1, na het
trimmen](SRR26913194_1_FASTQ_base_quality_trimmed.png) Wat gelijk opvalt
is dat de algehele kwaliteit is verbeterd, dit is te zien aan dat veel
van de "boxplots" zijn vervangen door een lijn. De "boxplots" in dit
geval bestaan slechts uit de strepen voor de 10% and 90% punten, maar
zijn in de getrimde data vrijwel geheel vervangen door een enkele
horizontale lijn. Alleen aan het begin van de data en aan het einde is
te zien dat de data nog van iets mindere kwaliteit is.

Voor de reverse read geldt hetzelfde:

![](SRR26913194_2_FASTQ_base_quality.png)

![](SRR26913194_2_FASTQ_base_quality_trimmed.png)

### Summary

Wat opvalt in de summary van het FASTQC rapport voor zowel SRR26913194_1
als SRR26913194_2, is dat er een failure wordt gegeven bij '*per
sequence GC content* en een warning bij *sequence duplication levels*'.
Om te kijken wat dit betekent, ga ik kijken naar de documentatie van
FASTQC.

![Summary uit FastQC Report, forward
read](result_SRR26913194_1_1st_run.png)

![Summary uit FastQC Report, reverse
read](result_SRR26913194_2_1st_run.png)

### Per sequence GC content

FASTQC meet het GC-gehalte van de gehele sequentie in een bestand en
vergelijkt dit met een gemodelleerde normaalverdeling van het
GC-gehalte. In een willekeurige library wordt er verwacht dat er
ongeveer een normaalverdeling is van het GC-gehalte. Wanneer dit niet
het geval is, en er een afwijkende vorm te zien is, kan dit wijzen op
een probleem met de library. Een scherpe piek op de verdeling kan een
gevolg zijn van een specifieke contaminant (bijv. van adapters), een
bredere piek kan duiden op contaminatie met een andere soort. Een
failure bij dit onderdeel houdt in dat de totale deviatie van de
normaalverdeling gelijk is aan meer dan 30% van de reads [@FASTQC].

Bij het vergelijken van figuur .. en figuur .. met elkaar, valt het op
dat de reverse read meer afwijkt van de normaalverdeling, zoals ik had
verwacht. De reverse read lijkt 2 pieken te hebben.

Het GC-percentage is echter niet iets dat met Trimmomatic verbeterd kan
worden en wordt puur door de sequentie-data zelf veroorzaakt. Mogelijk
wordt deze afwijking in GC-percentage veroorzaakt door het gebruikte
genpanel.

![GC-gehalte uit FastQC Report, forward
read](SRR26913194_1_GC_content_1st_run.png)

![GC-gehalte uit FastQC Report, reverse
read](SRR26913194_2_GC_content_1st_run.png)

### Sequence duplication levels

Normaal horen sequenties maar één keer voor te komen in de uiteindelijke
dataset, een lage hoeveelheid aan duplicaties van sequenties duidt op
een hoge coverage van de target sequentie, maar een hoge hoeveelheid aan
duplicaties kan het gevolg zijn van een bias. Deze module telt het
aantal duplicaten voor elke sequentie in een library en maakt hiervan
een plot, met het percentage van de sequentie en de bijbehorende
hoeveelheid duplicaten. Hierbij Kijkt het alleen naar de eerste 100.000
sequenties van de data om geheugen te besparen, omdat dit genoeg is om
een goed beeld te vormen. Dit onderdeel laat een warning zien als meer
dan 20% van de data bestaat uit niet-unieke sequenties[@FASTQC].

Figuur .. en figuur .. lijken sterk op elkaar, bij beiden is er sprake
van een piek bij sequence duplication level = \>10. Een duidelijk
verschil is dat het percentage overblijvende sequenties na dedupliceren
60.49% is voor de reverse read en 58.99% bij de forward read. Dit
betekent dat de forward read 1.50% meer sequentie duplicaties heeft dan
de reverse read.

![Sequence Duplication Levels uit FastQC Report, forward
read](SRR26913194_1_sequence_duplication_levels_1st_run.png)

![Sequence Duplication Levels uit FastQC Report, reverse
read](SRR26913194_2_sequence_duplication_levels_1st_run.png)

# Coverage berekenen

-   minimale coverage moet 20 zijn, anders is het moeilijk om
    onderscheid te maken tussen een variant en een sequencing error
-   readlengte hangt af van de dataset, in dit geval is het 75x2
-   het menselijk genoom is 3,137,161,264 bases, maar omdat er gebruik
    is gemaakt van een genpanel wordt er naar 'slechts' 1,000,000 basen
    gekeken.

De verwachte coverage kan worden berekend met de Lander/Waterman
formule:

C = LN / G

C: coverage L: readlengte N: aantal reads G: captured region

De readlengte (L) is 2x75, ofwel 150 Het aantal reads (N) is wat er is
overgebleven na gebruik van Trimmomatic, dat zijn er in dit geval
20877004 De captured region (G) is het aantal basenparen in het
gebruikte genpanel, dit zijn er 1,000,000

```{r}
C <- (2 * 75) * 20877004 / 1000000
paste("De coverage is:", C)
```

-   Coverage = 20
-   Readlengte = 300
-   Aantal reads = 25000000
-   Captured region (genpanel) = 1000000

```{r}
C <- 20
L <- 300
G <- 1000000
N <- 25000000
n <- (L * N) / C

paste("Aantal patienten die kunnen worden gesequenced:", n / G)
```

# BWA

| Input Parameter                                                               | Value                                                |
|------------------------------------------|------------------------------|
| Will you select a reference genome from your history or use a built-in index? | cached                                               |
| Using reference genome                                                        | hg38                                                 |
| Select input type                                                             | paired                                               |
| Select first set of reads                                                     | 7: Trimmomatic on SRR26913194_1.fastq.gz (R1 paired) |
| Select second set of reads                                                    | 8: Trimmomatic on SRR26913194_1.fastq.gz (R2 paired) |
| Set advanced paired end options?                                              | do_not_set                                           |
| Set read groups information?                                                  | do_not_set                                           |
| Select analysis mode                                                          | illumina                                             |

# Duplicate reads

Technische duplicaten moeten worden gemarked voordat de mapping plaats
kan vinden. Dit heb ik met behulp van de 'Mark Duplicates' tool gedaan.
De tool voegt een 'flag' toe aan de duplicates (en verwijderd deze dus
niet!), zodat andere tools de duplicates zullen negeren.

| Input Parameter                                                                                                            | Value                                                              |
|----------------------------------------------|--------------------------|
| Select SAM/BAM dataset or dataset collection                                                                               | 14: Map with BWA on data 8 and data 7 (mapped reads in BAM format) |
| If true do not write duplicates to the output file instead of writing them with appropriate flags set                      | 0                                                                  |
| Assume the input file is already sorted                                                                                    | 0                                                                  |
| The scoring strategy for choosing the non-duplicate among candidates                                                       | SUM_OF_BASE_QUALITIES                                              |
| Regular expression that can be used in unusual situations to parse non-standard read names in the incoming SAM/BAM dataset | Empty.                                                             |
| The maximum offset between two duplicte clusters in order to consider them optical duplicates                              | 100                                                                |
| Barcode Tag                                                                                                                | Not available.                                                     |
| Select validation stringency                                                                                               | Lenient                                                            |

# IGV

Met behulp van IGV ga ik opzoek naar een variant in een gen dat ik heb
gekozen uit het genpanel, namelijk ABL1.

**Gegevens gevonden variant**:

```         
chr9:130.885.614
Total count: 926
A : 502 (54%, 266+, 236- )
C : 1 (0%, 1+, 0- )
G : 423 (46%, 244+, 179- )
T : 0
N : 0
```

De patiënt is heterozygoot voor het allel voor dit gen, dit is te zien
aan dat zowel de base A, als T ongeveer 50% voorkomen. De variant
bevindt zich aan een exon, dit is te zien aan dat er een bijbehorende
referentiesequentie wordt weergegeven onder de data van de patiënt.

Het variant codeert normaal, volgens de referentiesequentie, samen met 2
andere basen (samen CCA) voor het aminozuur proline. Bij de data van de
patiënt komen 2 verschillende sequenties voor, namelijk CCA en CCG.
Zowel CCG als CCA coderen voor het aminozuur proline, er is dus sprake
van een silent of 'synonymous' mutatie.

![Overzicht van het gevonden variant in gen ABL1, in
IGV](igv_variant.png)

# Analyse van varianten

Soorten files:

-   BED-file: beschrijft de locaties van de exons
-   BAM-file: bevat de gemapte reads
-   VCF-file: bevat alle gevonden varianten

Inladen BED-data

```{r exons_per_chromosome_barplot}
(bed_data <- read.table("Galaxy21-[medulloblastoma_gene_panel_V3_ucsc.bed].bed"))

names(bed_data) <- c("chrom", "chromStart", "chromEnd", "gene")

(exons_per_chromosome <- table(bed_data$chrom))

barplot(exons_per_chromosome, las = 2, ylab = "Number of exons", xlab = "Chromosome")


```

Uit bovenstaande plot is de verdeling van exonen per chromosoom te zien,
hierbij valt op dat chromosoom 9 en 12 de meeste exonen hebben.

```{r}
# Maakt een dataframe van alleen de kolommen 'chrom' en 'gene' van bed_data
chrom_gene <- bed_data[c("chrom", "gene")]

# Behoudt slechts één van de genrijen per uniek gen op het chromosoom
(unique_genes <- unique(chrom_gene) )

# Maakt een tabel van de data, zodat dit kan worden gebruikt voor de barplot
gene_count <- table(unique_genes$chrom)


barplot(gene_count, las = 2, ylab = "Number of genes", xlab = "Chromosome")

```

Uit bovenstaande figuur kan het aantal genen per chromosoom worden
afgelezen. Hieruit blijkt dat zowel chromosoom 12 als chromosoom 9
relatief veel genen bevatten, dit was te verwachten aan de hand van de
resultaten uit de eerdere grafiek met de exonen. Echter blijkt dat ook
chromosoom 1 relatief veel genen bevat, terwijl dit minder exonen had
dan chromosoom 9 en 12. Dit kan te verklaren zijn doordat chromosoom 1
misschien genen bevat met relatief weinig exonen.

IRange: manier om een regio in een sequentie aan te geven, met start en
stopcoordinaten GenomicRanges: start en stopcoordinaten,
chromosoomnummer en welke streng (+/-)

IRange gebruiken om BED-file data op te slaan:

```{r}
# Print all rows where the gene name is for example 'SOD2'
bed_data[bed_data$gene == "EZH2", ]

# Get the data as a subset of the cardiopanel data
ezh2 <- bed_data[bed_data$gene == "EZH2", ]

# Assign whole columns to the IRanges arguments
ranges <- IRanges(start = ezh2$chromStart,
                  end = ezh2$chromEnd,
                  names = ezh2$gene)
# Print the object
ranges

```

```{r}
# Calculate and print the length of a gene
cat("Length of EZH2:", sum( width(ranges) ), "bp")

```

```{r}
# Converts iRanges to GRanges, adding the chromosome name
granges <- GRanges(seqnames = ezh2$chrom,
                   ranges = ranges)
granges

```

IRange: - Geeft chromStart en chromEnd aan en berekent hiermee de width
of de lengte van een gen GRange: - geeft aan op welk chromosoom het gen
ligt

Functions such as width() applied to an IRanges object gives the width
column and the ranges() function applied to a GRanges object gives the
IRanges object contained within.

This more challenging assignment results in yet another type of object,
named a GRangesList that contains multiple GRanges objects; one for each
gene such as shown in the above example. So, in order to do that we need
to:

Create an empty (standard) R list, Iterate over all of our genes in the
BED file, Read the part about iteration below and the hints about the
split function to get the gene names and data easily accessible. For
each gene, create a GRanges object and add it to the list, including the
gene name (use the following form: my_list[[gene_name]] \<- data) and
Convert the complete list into a GRangesList object. Use the conversion
as explained in the GRanges manual: bed_data \<- GRangesList(bed_data)
given that the list is called bed_data.

my_list \<- list(comp1, comp2 ...)

```{r}
# aanmaken lege lijst
gene_list <- list()

# opsplitten data per gen, geeft losse dataframe per gen
bed_splitted <- split(bed_data, bed_data$gene)


for (gene in names(bed_splitted)) {

    # gene_data neemt de waarde aan van de bed_data rijen waarvan het gen gelijk is aan het gen in names(bed_splitted)
  
    gene_data <- bed_data[bed_data$gene == gene, ]
    
    # creeeren van Irange voor elk gen, door chromstart, end en gene mee te geven
    ranges <- IRanges(start = gene_data$chromStart,
                      end = gene_data$chromEnd,
                      names = gene_data$gene)
    
    
    # lengte printen
    #cat("Length of", gene, ":", sum( width(ranges) ), "bp.\n")
    
    # GRange aanmaken voor elk gen, door chrom mee te geven
    granges <- GRanges(seqnames = gene_data$chrom,
                       ranges = ranges)
    
    # GRanges toevoegen per gen
    gene_list[[gene]] <- granges
    
    

}

gene_list <- GRangesList(gene_list)


gene_list
```

```{r}
# Check the length (in basepairs) of a single gene (exons only)
ranges_width <- ranges(gene_list)
ranges_width <- sum(width(ranges_width))
summary(ranges_width)
hist(ranges_width)
```

```{r}
# lage waarden zijn weg
# 0 staat niet bij de oorsprong
gap.barplot(ranges_width, gap=c(12000, 18000), las=2, ylab = "lengte v.h. gen", xlab = "Index v.h. gen")


gap.barplot(ranges_width, gap=c(10000, 10001), las=2, ylab = "lengte v.h. gen", xlab = "Index v.h. gen")
```


```{r}
#BamFile
#Create a BamFile object by providing both the file and index parameters

bam_file <- BamFile("Galaxy5-[MarkDuplicates_on_data_1__MarkDuplicates_BAM_output].bam", index="Galaxy5-[MarkDuplicates_on_data_1__MarkDuplicates_BAM_output].bai")
```

```{r}
#ScanBamParam: Sets the parameters for selecting a certain region from the genome using GRanges (i.e., a gene from our BED-data)

(abl1 <- gene_list[["ABL1"]])

abl1_region <- ScanBamParam(which = abl1)


```

```{r}
#pileup: Actually retrieves the region of interest given the BamFile and parameters supplied.
abl1_df <- pileup(file = bam_file, scanBamParam = abl1_region)
head(abl1_df)
```

```{r}
# create empty list
pileup_list <- list()


# iterate over BED-data (Granges)
for (gene_name in names(gene_list)) {

 # get pileup data for each gene by creating scanbamparam
 gene_region <- gene_list[[gene_name]]
 scan_region <- ScanBamParam(which = gene_region)

 # executing pileup function
 gene_df <- pileup(file = bam_file, scanBamParam = scan_region)
 
 # add pileup data to list
 pileup_list[[gene_name]] <- gene_df

}

```

```{r}
head(pileup_list[["ABL1"]])

```

```{r}

coverage <- list()

for (gene_name in names(pileup_list)) {
  
coverage[[gene_name]] = aggregate(x = list(count=pileup_list[[gene_name]]$count), 
                     by = list(pos=pileup_list[[gene_name]]$pos), FUN=sum)

}

```

```{r}
mean(coverage[["AKT3"]]$count)

```

```{r}
ranges

sum( width(ranges) )
```

```{r}
(length <- tail(coverage[["ABL1"]]$pos, 1) - coverage[["ABL1"]]$pos[1])

```

```{r}
# Tell R not to complain...
options(stringsAsFactors = FALSE)

# Create empty data-frame, but specify columns and data types
coverage_df <- data.frame(length=integer(), avg_coverage=numeric(), low_coverage=integer(), low_coverage_perc=numeric())

for (gene_name in names(gene_list)){
  
length <- tail(coverage[[gene_name]]$pos, 1) - coverage[[gene_name]]$pos[1]
avg_coverage <- round(mean(coverage[[gene_name]]$count), 1)
low_coverage <- sum(coverage[[gene_name]]$count < 30)
low_coverage_perc <- round(low_coverage/(sum(coverage[[gene_name]]$count)) * 100, 1)


# Create a new row of data, stored as a named list (important)
coverage_df <- rbind(coverage_df, list(gene_name=gene_name, length=length , avg_coverage=avg_coverage, low_coverage=low_coverage, low_coverage_perc=low_coverage_perc ))


}

head(coverage_df)

```

```{r}
# to further inspect low coverage genes
for (gene_name in coverage_df){
  
  low_coverage_genes <- coverage_df$gene_name[coverage_df$low_coverage_perc > 0.7]
}
```

Alle genen waarbij de 'low coverage percentage' hoger was dan 0.7, zijn
toegevoegd aan de lijst 'low_coverage_genes', de lijst bevat de volgende
genen:

```{r}
low_coverage_genes_info <- list()

for (gene in low_coverage_genes){
  low_coverage_genes_info[[gene]] <- subset(coverage_df, gene_name == gene)
  
}

# laat info zien over de 3 genen met lage coverage
low_coverage_genes_info
```

Deze genen dienen nader geïnspecteerd te worden met IGV

# LoFreq

| Input Parameter                            | Value                                                    |
|-------------------------------|-----------------------------------------|
| Input reads in BAM format                  | 20: MarkDuplicates on data 14: MarkDuplicates BAM output |
| Choose the source for the reference genome | cached                                                   |
| Reference genome                           | hg38                                                     |
| Call variants across                       | genome                                                   |
| Types of variants to call                  | Only SNVs                                                |
| Variant calling parameters                 | 0                                                        |
| Variant filter parameters                  | set_lofreq_standard                                      |
| sig                                        | 0.01                                                     |
| bonf                                       | dynamic                                                  |
| others                                     | Empty.                                                   |

```{r, eval=FALSE}
# Inlezen data

lofreq_data <- read.table(file = "..\\Data\\medulloblastoma_variant_detection.vcf")

# Hernoemen kolommen
names(lofreq_data) <- c("chrom", "pos", "ID", "ref", "alt", "count", "filter", "lofreq")

# Opsplitsen data in lofreq kolom
lofreq_data <- lofreq_data %>%
  separate(lofreq, 
           into = c("DP", "AF", "SB", "DP4"),
           sep = ";")

```

```{r}
# Haalt string "AF="  weg van AF data
lofreq_data$AF <- gsub("AF=", "", lofreq_data$AF)

# Zet datatype van AF-kolom om naar numeric
AF_data <- as.numeric(lofreq_data$AF)
```

```{r}
# Ranges aanmaken
ranges <- IRanges(start = lofreq_data$pos,
                  end = lofreq_data$pos)

# GRanges aanmaken
variant_granges <- GRanges(seqnames = lofreq_data$chrom,
                   ranges = ranges)

# Filter AF_data op waarden boven 0.3
lofreq_data$AF <- gsub("AF=", "", lofreq_data$AF)


#AF_data <- AF_data[AF_data > 0.3]

# Voegt AF_kolom bij variant_granges
mcols(variant_granges) <- DataFrame(AF= AF_data)


```

```{r}
overlaps <- data.frame(findOverlaps(variant_granges, gene_list))

# Rijen die na filterstappen zijn overgebleven (dus varianten die voorkomen in exonen én een allele frequency van hoger dan 30% heeft), de +17 is om rekening te houden met de header lines
intersect_rows <- intersect(overlaps$queryHits, which(variant_granges$AF >= 0.3))+17

```

```{r}
unfiltered_vcf <- readLines("..\\Data\\medulloblastoma_variant_detection.vcf")

filtered_vcf <- unfiltered_vcf[intersect_rows]

write(filtered_vcf, file = "filtered_data.vcf")
```

**queryhits**: de varianten (die binnen een gen liggen) **subjecthits**:
het gen

```{r}

variants_filtered <- variant_granges[overlaps$queryHits]



hist(variants_filtered$AF, breaks = 20)
```

**Conclusie figuur**

De allelfrequentie (AF) bij de overgebleven varianten ligt grotendeels
rond de 50% en rond de 100%. Dit kan wijzen op varianten die heteryzgoot
zijn voor de variant (1 allel dat overeenkomt met ref_gen en 1 allel met
variant) en op varianten die homozygoot zijn voor de variant, waar de
variant dus 100% van de reads voorkomt.

```{r}
# maak dataframe van de subjecthits
genes_freq <- data.frame(table(overlaps$subjectHits))

# vervang kolomnamen
names(genes_freq) <- c("gene", "freq")

# haal alle gennamen op uit bed_data
genes <- unique(bed_data$gene)

# gebruik indices om gennamen voor gefilterde genen uit genes te halen
genes_freq$gene <- genes[genes_freq$gene]

```

```{r}
# x-as genen niet zichtbaar

genes_freq_subset <- subset(genes_freq, freq > 1)
genes_freq_subset

barplot(genes_freq_subset$freq, cex.names=0.5, names=genes_freq_subset$gene, las=2)

```



# Databases

## ClinVar
|INFO Tag|Comment|
|---|---|
|AF_ESP, AF_EXAC, AF_TGP|Allele frequency is reported in three tags, one for each source of data. AF_ESP reports allele frequency from GO-ESP. AF_EXAC reports allele from the ExAC Consortium. AF_TGP reports allele from the 1000 Genomes Project.|
|ALLELEID|The ClinVar Allele ID for the variant|
|CLNDNINCL|Used only for “included” variants. ClinVar's preferred disease name for an interpretation for a haplotype or genotype that includes this variant|
|CLNDISDBINCL|Used only for “included” variants. The database name and identifier for the disease name for an interpretation for a haplotype or genotype that includes this variant. Multiples are separated by a pipe|
|CLNHGVS|The top-level genomic HGVS expression for the variant. This may be on an accession for the primary assembly or on an ALT LOCI|
|CLNSIGINCL|Used only for “included” variants. The clinical significance of a haplotype or genotype that includes this variant. It is reported as pairs of Variation ID for the haplotype or genotype and the corresponding clinical significance|
|CLNVI|Identifiers for the variant in other databases, e.g. OMIM Allelic variant IDs|
|CLNVC|The type of variation, using terms from Sequence Ontology|
|CLNVCSO|The Sequence Ontology identifier for the type of variation|
|MC|The predicted molecular consequence of the variant. It is reported as pairs of the Sequence Ontology (SO) identifier and the molecular consequence term joined by a vertical bar. Multiple values are separated by a comma. This tag replaces ASS, DSS, INT, NSF, NSM, NSN, R3, R5, SYN, U3, and U5 in the old format|

https://www.ebi.ac.uk/ols4/search?q=medulloblastoma&ontology=mondo voor mondo
MONDO:0007959 = medulloblastoma


CLNDISDB (ClinVar Disease Database): Dit veld bevat links naar medische databases zoals OMIM, MedGen, MONDO, etc., waarin ziekte-informatie beschikbaar is
Clinvar
CLNDN=Joubert_syndrome_32|Medulloblastoma|Gorlin_syndrome|not_specified|not_provided|Familial_meningioma;CLNHGVS=NC_000010.11:g.102627262T>C;CLNREVSTAT=criteria_provided,_multiple_submitters,_no_conflicts;CLNSIG=Benign;CLNVC=single_nucleotide_variant;CLNVCSO=SO:0001483;CLNVI=ClinGen:CA5667986;GENEINFO=SUFU:51684;MC=SO:0001627|intron_variant;ORIGIN=1;RS=12414407


### Kolommen met allelfrequentie

- AF = allelfrequentie van variant in de afgelezen reads
- AF_ESP = allelfrequentie van variant in Exome Sequencing Project (ESP) database
- AF_EXAC = allelfrequentie van variant in Exome Aggregation Consortium (ExAC) database
- AF_TGP = allelfrequentie van variant in 1000 Genomes Project (TGP) database


```{r}
read.table("variants_step3.vcf")

```


CHROM POS ID REF ALT FILTER DP AF ANN[*].ALLELE ANN[*].EFFECT ANN[*].IMPACT ANN[*].GENE ANN[*].GENEID ANN[*].FEATURE ANN[*].FEATUREID ANN[*].BIOTYPE ANN[*].RANK ANN[*].HGVS_C ANN[*].HGVS_P ANN[*].CDNA_POS ANN[*].CDNA_LEN ANN[*].CDS_POS ANN[*].CDS_LEN ANN[*].AA_POS ANN[*].AA_LEN ANN[*].DISTANCE ANN[*].ERRORS CLNDISDB CLNDN CLNREVSTAT CLNVC CLNVCSO CLNVI CLNHGVS CLNSIG ORIGIN MC GENEINFO ALLELEID DP AF SB DP4


CHROM POS ID REF ANN[*].GENE ALT AF_ESP AF_EXAC AF_TGP ANN[*].IMPACT CLNDN CLNSIG CLNVC CLNREVSTAT CLNHGVS

mutation taster
mutation assesor
sift

de data wordt ineenkeer dubbel na extract columns tool


Belangrijke kolommen om te houden:

- CLNDN disease name, filteren op medulloblastoma en/of andere ziekten die vaak samen voorkomen
- AF (hoe hoger hoe beter)
- AF databases (hoe lager hoe beter)
- CLNREVSTAT review status, geeft aan hoe betrouwbaar
- CLNVC  geeft aan om wat voor mutatie het gaat
- CLNHGVS geeft variant id om verder info te zoeken op NCBI


- **Kolom 1**: chromosoomnaam (chr)
- **Kolom 2**: positie op het chromosoom (int)
- **Kolom 3**: ID, een '.' betekent dat er geen ID is toegewezen (chr)
- **Kolom 4**: referentiebase, A,C,G,T of N (chr)
- **Kolom 5**: gevonden base, A,C,G,T of N (chr)
- **Kolom 6**: kwaliteitsscore (Phred), '.' betekent dat er geen score is (chr)
- **Kolom 7**: filter status, "PASS" betekent dat het variant het door alle filters (meegegeven argumenten) heeft gehaald en dus als variant is gecalled (chr)
- **Kolom 8**: informatie over de data (chr):
  - *ADP*: Average per-sample depth van basen met Phred-score >= 28
  - *WT*: hoeveel van de samples geen variant heeft (gecalled met ref.gen)
  - *HET*: hoeveel van de samples heterozygoot is gecalled voor het variant
  - *HOM*: hoeveel van de samples homozygoot is gecalled voor het variant
  - *NC*: hoeveel van de samples niet gecalled is
- **Kolom 9**: geeft de format aan voor de informatie dat wordt gegeven voor de samples in de opvolgende kolommen, in dit geval sample 1 en 2 in kolom 10 en 11 (chr):
  - *GT*: genotype **verder uitleggen**
  - *GQ*: genotype quality
  - *SDP*: raw read depth volgens SAMtools
  - *DP*: quality read depth van basen met een Phred score >= 28
  - *RD*: depth van basen die overeenkomen met referentiegenoom
  - *AD*: depth van basen die afwijken van referentiegenoom (varianten)
  - *FREQ*: variant allele frequency
  - *PVAL*: P-value volgens Fisher's Exact Test
  - *RBQ*: gemiddelde kwaliteit van basen die met referentiegenoom overeenkomen
  - *ABQ*: gemiddelde kwaliteit van basen die van referentiegenoom afwijken (varianten)
  - *RDF*: depth van basen die met referentiegenoom overeenkomen, op forward strand
  - *RDR*: depth van basen die met referentiegenoom overeenkomen, op reverse strand
  - *ADF*: depth van basen die van referentiegenoom afwijken (varianten), op forward strand
  - *ADR*: depth van basen die van referentiegenoom afwijken (varianten), op reverse strand
- **Kolom 10**: geeft informatie over sample 1, in het format van kolom 9 (chr)
- **Kolom 11**: geeft informatie over sample 2, in het format van kolom 9 (chr)


Li-Fraumeni syndrome
Li-Fraumeni syndrome is caused by PVs in the TP53 gene. TP53 is apparently the best-studied tumor suppressor gene, which is involved in the regulation of DNA damage response, programmed cell death, cell cycle and several other biological processes. Population occurrence of TP53 germline heterozygosity is well below 1:10000, although some communities demonstrate a noticeable frequency of founder hypomorphic TP53 variants[5,6,142]. Earlier family-based studies suggested nearly-fatal penetrance for TP53 germline PVs, although recent data indicate that some carriers of TP53 pathogenic alleles manage to achieve late adulthood without being affected by cancer disease[8].

TP53 PVs render a highly increased risk of childhood cancers. Li-Fraumeni syndrome-associated pediatric malignancies include adrenal cortical carcinomas, choroid plexus carcinomas, rhabdomyosarcomas and medulloblastomas. Adult cancers are mainly represented by very-young-onset BC in females as well as lung carcinomas, osteosarcomas, soft-tissue sarcomas and brain tumors[8,63,143]. Breast carcinomas arising in TP53 PV carriers frequently carry HER2 amplification[144]. Li-Fraumeni syndrome related lung carcinomas are characterized by an exceptionally high frequency of EGFR somatic mutations[129,145]. Carriers of TP53 PVs also have highly elevated risk of hematological malignancies[146]. The analysis of specific groups of consecutive patients revealed that Li-Fraumeni syndrome is a significant contributor to the incidence of pediatric cancers, very-young-onset breast carcinomas and osteosarcomas[142,146-150].

https://www.ncbi.nlm.nih.gov/pmc/articles/PMC9993141/


Genen die in de data terug te vinden zijn:
- SMARCA4
- TP53
- BRCA2
- PTCH1
- APC
- SUFU
- MSH6


```{r}
# maak dataframe van de subjecthits
genes_freq <- data.frame(table(overlaps$subjectHits))

# vervang kolomnamen
names(genes_freq) <- c("gene", "freq")

# haal alle gennamen op uit bed_data
genes <- unique(bed_data$gene)

# gebruik indices om gennamen voor gefilterde genen uit genes te halen
genes_freq$gene <- genes[genes_freq$gene]

```

```{r}
features <- bed_data[bed_data$gene == "CDK6", ]
overlaps$Gene <- names(gene_list)[overlaps$subjectHits]

sample.gr <- variants_filtered[unlist(subset(overlaps, Gene == "CDK6", select = queryHits))]

sample.gr$score <- sample.gr$AF * 100
```

```{r}
lolliplot(sample.gr, features, ylab = "Allele Frequency (%)")

```


https://www.tandfonline.com/doi/full/10.2217/fnl-2018-0030#:~:text=The%20most%20prevalent%20among%20those,not%20exclusive%20to%20WNT%20MB.

